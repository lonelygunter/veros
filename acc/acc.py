#!/usr/bin/env python

"""
This Veros setup file was generated by

   $ veros copy-setup acc

on 2026-01-07 13:45:27 UTC.
"""

__VEROS_VERSION__ = '1.6.1'

if __name__ == "__main__":
    raise RuntimeError(
        "Veros setups cannot be executed directly. "
        f"Try `veros run {__file__}` instead."
    )

# -- end of auto-generated header, original file below --


from veros import VerosSetup, veros_routine
from veros.variables import allocate, Variable
from veros.distributed import global_min, global_max
from veros.core.operators import numpy as npx, update, at


class ACCSetup(VerosSetup):
    """A model using spherical coordinates with a partially closed domain representing the Atlantic and ACC.

    Wind forcing over the channel part and buoyancy relaxation drive a large-scale meridional overturning circulation.

    This setup demonstrates:
     - setting up an idealized geometry
     - updating surface forcings
     - basic usage of diagnostics

    `Adapted from pyOM2 <https://wiki.cen.uni-hamburg.de/ifm/TO/pyOM2/ACC%202>`_.
    """

    @veros_routine
    def set_parameter(self, state):
        """
        Configure model parameters and physics settings.
        """
        settings = state.settings
        
        # Basic model identification
        settings.identifier = "acc"
        settings.description = "My ACC setup"

        # Grid dimensions: 30 longitude × 42 latitude × 15 depth levels
        settings.nx, settings.ny, settings.nz = 30, 42, 15
        
        # Time steps: 4800s for momentum, ~12 hours for tracers (temp/salt)
        settings.dt_mom = 4800
        settings.dt_tracer = 86400 / 2.0
        
        # Run length: 365 days
        settings.runlen = 86400 * 7300

        # Grid origin: starts at 0°E, 40°S
        settings.x_origin = 0.0
        settings.y_origin = -40.0

        # Use lat/lon coordinates and allow periodic boundary in x (longitude)
        settings.coord_degree = True
        settings.enable_cyclic_x = True

        # Neutral diffusion (isopycnal mixing) parameters
        # K_iso_0: base diffusivity (1000 m²/s)
        # K_iso_steep: diffusivity for steep slopes (500 m²/s)
        settings.enable_neutral_diffusion = True
        settings.K_iso_0 = 1000.0
        settings.K_iso_steep = 500.0
        settings.iso_dslope = 0.005     # Critical slope for tapering
        settings.iso_slopec = 0.01      # Cutoff slope
        
        # Skew diffusion (Gent-McWilliams parameterization)
        settings.enable_skew_diffusion = True

        # Horizontal friction with cosine scaling for spherical coordinates
        # A_h scales with grid size cubed
        settings.enable_hor_friction = True
        settings.A_h = (2 * settings.degtom) ** 3 * 2e-11
        settings.enable_hor_friction_cos_scaling = True
        settings.hor_friction_cosPower = 1

        # Bottom friction coefficient
        settings.enable_bottom_friction = True
        settings.r_bot = 1e-5

        # Use implicit vertical friction solver (more stable)
        settings.enable_implicit_vert_friction = True

        # TKE (Turbulent Kinetic Energy) mixing scheme parameters
        settings.enable_tke = True
        settings.c_k = 0.1              # TKE production coefficient
        settings.c_eps = 0.7            # TKE dissipation coefficient
        settings.alpha_tke = 30.0       # TKE efficiency parameter
        settings.mxl_min = 1e-8         # Minimum mixing length
        settings.tke_mxl_choice = 2     # Mixing length parameterization choice
        settings.kappaM_min = 2e-4      # Minimum momentum diffusivity
        settings.kappaH_min = 2e-5      # Minimum tracer diffusivity
        settings.enable_kappaH_profile = True  # Use depth-dependent diffusivity

        # EKE (Eddy Kinetic Energy) parameterization
        # Represents mesoscale eddy effects
        settings.K_gm_0 = 1000.0        # Base GM coefficient
        settings.enable_eke = True
        settings.eke_k_max = 1e4        # Maximum eddy kinetic energy
        settings.eke_c_k = 0.4          # EKE production coefficient
        settings.eke_c_eps = 0.5        # EKE dissipation coefficient
        settings.eke_cross = 2.0        # Cross-term coefficient
        settings.eke_crhin = 1.0        # Critical Richardson number
        settings.eke_lmin = 100.0       # Minimum eddy length scale (m)
        settings.enable_eke_superbee_advection = True     # Flux-limiter scheme
        settings.enable_eke_isopycnal_diffusion = True    # Along-isopycnal diffusion

        # IDEMIX (Internal wave mixing) - disabled for this setup
        settings.enable_idemix = False

        # Equation of state: type 3 uses a specific formulation
        settings.eq_of_state_type = 3

        # Define custom variables for surface forcing
        var_meta = state.var_meta
        var_meta.update(
            t_star=Variable("t_star", ("yt",), "deg C", "Reference surface temperature"),
            t_rest=Variable("t_rest", ("xt", "yt"), "1/s", "Surface temperature restoring time scale"),
        )

    @veros_routine
    def set_grid(self, state):
        """Define the vertical and horizontal grid spacing.
        
        Sets up non-uniform vertical layers (finer near surface)
        and uniform horizontal spacing.
        """
        vs = state.variables
        
        # Vertical grid spacing (meters) - higher resolution near surface
        # Values increase with depth from 50m to 690m per level
        ddz = npx.array(
            [50.0, 70.0, 100.0, 140.0, 190.0, 240.0, 290.0, 340.0, 390.0, 440.0, 490.0, 540.0, 590.0, 640.0, 690.0]
        )
        
        # Horizontal grid spacing: 2° in both x (longitude) and y (latitude)
        vs.dxt = update(vs.dxt, at[...], 2.0)
        vs.dyt = update(vs.dyt, at[...], 2.0)
        
        # Vertical spacing: reverse array and scale by 2.5
        # This creates a stretched vertical grid
        vs.dzt = update(vs.dzt, at[...], ddz[::-1] / 2.5)

    @veros_routine
    def set_coriolis(self, state):
        """Calculate Coriolis parameter (f = 2Ω sin(φ)).
        
        The Coriolis force depends on latitude and Earth's rotation rate.
        """
        vs = state.variables
        settings = state.settings
        
        # Coriolis parameter: f = 2 * Ω * sin(latitude)
        # where Ω is Earth's angular velocity
        vs.coriolis_t = update(
            vs.coriolis_t, at[...], 2 * settings.omega * npx.sin(vs.yt[None, :] / 180.0 * settings.pi)
        )

    @veros_routine
    def set_topography(self, state):
        """Define ocean bottom topography.
        
        Creates a partially closed domain:
        - Closed basin (Atlantic-like) for x ≤ 1°
        - Open channel (ACC-like) for x > 1° and y < -20°
        """
        vs = state.variables
        
        # Create 2D meshgrid of horizontal coordinates
        x, y = npx.meshgrid(vs.xt, vs.yt, indexing="ij")
        
        # kbot = 1 (bottom at surface) where x > 1° OR y < -20°
        # This creates land in the northern part and an open channel in the south
        vs.kbot = npx.logical_or(x > 1.0, y < -20).astype("int")

    @veros_routine
    def set_initial_conditions(self, state):
        """Set initial temperature, salinity, and forcing fields.
        
        Establishes initial stratification and surface forcing patterns
        that drive the meridional overturning circulation.
        """
        vs = state.variables
        settings = state.settings

        # Initial temperature: linear decrease with depth from 15°C at surface
        # Multiplied by mask to ensure zero in land cells
        vs.temp = update(vs.temp, at[...], ((1 - vs.zt[None, None, :] / vs.zw[0]) * 15 * vs.maskT)[..., None])
        
        # Initial salinity: uniform 35 PSU (practical salinity units)
        vs.salt = update(vs.salt, at[...], 35.0 * vs.maskT[..., None])

        # Wind stress forcing setup
        # Get global min/max of latitude arrays for wind stress calculation
        yt_min = global_min(vs.yt.min())
        yu_min = global_min(vs.yu.min())
        yt_max = global_max(vs.yt.max())
        yu_max = global_max(vs.yu.max())

        # Zonal wind stress (taux) with two regimes:
        taux = allocate(state.dimensions, ("yt",))
        
        # Southern channel: sinusoidal wind stress (westerlies)
        taux = npx.where(vs.yt < -20, 0.1 * npx.sin(settings.pi * (vs.yu - yu_min) / (-20.0 - yt_min)), taux)
        
        # Northern region: wind stress increasing northward (trade winds)
        taux = npx.where(vs.yt > 10, 0.1 * (1 - npx.cos(2 * settings.pi * (vs.yu - 10.0) / (yu_max - 10.0))), taux)
        
        # Apply mask to ensure zero wind stress over land
        vs.surface_taux = taux * vs.maskU[:, :, -1]

        # Surface heat flux forcing via temperature restoring
        # t_star: reference surface temperature profile
        vs.t_star = allocate(state.dimensions, ("yt",), fill=15)
        
        # Southern latitudes: temperature increases from pole to -20°
        vs.t_star = npx.where(vs.yt < -20, 15 * (vs.yt - yt_min) / (-20 - yt_min), vs.t_star)
        
        # Northern latitudes: temperature decreases poleward from 20°
        vs.t_star = npx.where(vs.yt > 20, 15 * (1 - (vs.yt - 20) / (yt_max - 20)), vs.t_star)
        
        # Temperature restoring timescale: 30 days
        vs.t_rest = vs.dzt[npx.newaxis, -1] / (30.0 * 86400.0) * vs.maskT[:, :, -1]

        # TKE surface forcing from wind stress
        if settings.enable_tke:
            # Calculate TKE input as (wind stress / ρ₀)^1.5
            # Average u and v components of wind stress
            vs.forc_tke_surface = update(
                vs.forc_tke_surface,
                at[2:-2, 2:-2],
                npx.sqrt(
                    (0.5 * (vs.surface_taux[2:-2, 2:-2] + vs.surface_taux[1:-3, 2:-2]) / settings.rho_0) ** 2
                    + (0.5 * (vs.surface_tauy[2:-2, 2:-2] + vs.surface_tauy[2:-2, 1:-3]) / settings.rho_0) ** 2
                )
                ** (1.5),
            )

        # IDEMIX internal wave forcing (if enabled)
        if settings.enable_idemix:
            vs.forc_iw_bottom = 1e-6 * vs.maskW[:, :, -1]   # Bottom generation
            vs.forc_iw_surface = 1e-7 * vs.maskW[:, :, -1]  # Surface generation

    @veros_routine
    def set_forcing(self, state):
        """Update time-dependent surface forcing.
        
        Called at each time step to apply surface temperature restoring,
        which drives the meridional overturning circulation.
        """
        vs = state.variables
        
        # Surface heat flux: restore toward reference temperature t_star
        # Forcing = (restoring coefficient) × (target temp - current temp)
        vs.forc_temp_surface = vs.t_rest * (vs.t_star - vs.temp[:, :, -1, vs.tau])

    @veros_routine
    def set_diagnostics(self, state):
        """Configure diagnostic output frequency and variables.
        
        Sets up what gets saved and how often for post-processing.
        """
        settings = state.settings
        diagnostics = state.diagnostics

        # Snapshot output: full 3D fields every 10 days
        diagnostics["snapshot"].output_frequency = 86400 * 10
        
        # Time-averaged output: yearly averages
        diagnostics["averages"].output_variables = (
            "salt",           # Salinity
            "temp",           # Temperature
            "u",              # Zonal velocity
            "v",              # Meridional velocity
            "w",              # Vertical velocity
            "psi",            # Streamfunction
            "surface_taux",   # Zonal wind stress
            "surface_tauy",   # Meridional wind stress
        )
        diagnostics["averages"].output_frequency = 365 * 86400.0
        diagnostics["averages"].sampling_frequency = settings.dt_tracer * 10
        
        # Overturning circulation diagnostics: ~weekly output
        diagnostics["overturning"].output_frequency = 365 * 86400.0 / 48.0
        diagnostics["overturning"].sampling_frequency = settings.dt_tracer * 10
        
        # Tracer monitoring: monthly output
        diagnostics["tracer_monitor"].output_frequency = 365 * 86400.0 / 12.0
        
        # Energy diagnostics: ~weekly output
        diagnostics["energy"].output_frequency = 365 * 86400.0 / 48
        diagnostics["energy"].sampling_frequency = settings.dt_tracer * 10

    @veros_routine
    def after_timestep(self, state):
        """Hook for custom operations after each time step.
        
        Currently unused but available for adding custom analysis
        or forcing updates during the simulation.
        """
        pass